---
title: "Assignment 1 Classification Trees, Bagging and Random Forests"
author: "Fleur Petit"
date: "09/09/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(memoise)
pima <- read.delim("pima.txt", sep = ",")
credit <- read.delim("credit.txt", sep = ",")

```

# Functions

```{r}

# Compute the impurity
impurity <- function(labels) {
  p0t <- length(labels[labels == 0])/length(labels)
  p0t*(1-p0t)
}

# Compute all possible splits on the values of a given variable
compute_splits <- function(values) {
  levels_sorted <- sort(unique(values)) # get unique values of the feature (I call them the levels)
  (levels_sorted[1:length(levels_sorted)-1] + levels_sorted[2:length(levels_sorted)])/2
}

get_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}
#https://stackoverflow.com/questions/2547402/how-to-find-the-statistical-mode

# Compute the best split for a given variable
bestsplit <- function(values, labels, minleaf) {
  splits <- compute_splits(values)

  imp_pa <- impurity(labels) # parent impurity
  
  # Empty arrays storing results
  lc_mode <- rep(NA, length(splits))
  rc_mode <- rep(NA, length(splits))
  nlc <- rep(NA, length(splits))
  nrc <- rep(NA, length(splits))
  impurity_reductions <- rep(NA, length(splits))
  for (i in 1:length(splits)) {
    split <- splits[i]
    labels_left <- labels[values <= split]
    labels_right <- labels[values > split]
    lc_mode[i] <- get_mode(labels_left)
    rc_mode[i] <- get_mode(labels_right)
    
    nlc[i] <- ifelse(is.null(sum(values <= split, na.rm = T)), 0, sum(values <= split, na.rm = T))
    nrc[i] <- ifelse(is.null(sum(values > split, na.rm = T)), 0, sum(values > split, na.rm = T))
    
    if (minleaf <= min(nlc[i], nrc[i])) { # check if split is allowed
      plc <- nlc[i]/length(labels)
      prc <- nrc[i]/length(labels)
      
      imp_lc <- impurity(labels_left)
      imp_rc <- impurity(labels_right)
      
      impurity_reductions[i] <- imp_pa - (plc*imp_lc + prc*imp_rc)
    }
  }
  
  highest_reduction <- max(impurity_reductions, na.rm = T)[1]
  if (highest_reduction > 0) { 
    index_best_split <- match(highest_reduction, impurity_reductions)[1]
    split <- splits[index_best_split]
    lc_mode <- lc_mode[index_best_split]
    rc_mode <- rc_mode[index_best_split]
    nlc <- ifelse(is.null(nlc[index_best_split]), 0, nlc[index_best_split])
    nrc <- ifelse(is.null(nrc[index_best_split]), 0, nrc[index_best_split])
    max_impurity_reduction <- impurity_reductions[index_best_split]
    node <- c(split = split, lc_mode = lc_mode, rc_mode = rc_mode, nlc = nlc, nrc = nrc, imp_red = max_impurity_reduction)
  } else {
    node <- c(split = NA, lc_mode = NA, rc_mode = NA, nlc = NA, nrc = NA, imp_red = NA)
  }
  node
}

# Compute the best split for each feat
per_feat <- function(df, labels, minleaf, use_feats) {
  split_per_feat <- c()
  for (feat in use_feats) {
    split_per_feat <- c(split_per_feat, feat = feat, bestsplit(values = df[[feat]], labels, minleaf))
  }
  split_per_feat
}

tree_grow <-
  function(layer_nr, #layer of the tree that we are in
           side, #root, left (less) or right (equal or more) of parent split
           df, #dataframe with all features
           labels, #labels per row of dataframe
           nmin, #not allowed to split when node has less than nmin observations
           minleaf, #not allowed to split if it results in a child with less than minleaf observations
           nfeat) { #number of features to use

    # Returns: a new node that is directly written to a csv file in the working directory
    
    feats <- colnames(df)
    use_feats <- sort(sample(feats, nfeat), decreasing = T)
    split_per_feat <- per_feat(df, labels, minleaf, use_feats)
    split_per_feat <- tibble(split_per_feat) %>%
      mutate(variable = names(split_per_feat),
             nr = sort(rep(1:nfeat, length(unique(
               names(split_per_feat)
             ))))) %>%
      rename(value = split_per_feat) %>%
      spread(variable, value) %>%
      drop_na()
      
      
    maximum_reduction <- max(split_per_feat[["imp_red"]], na.rm = T)
    best_feat <-
      split_per_feat[split_per_feat[["imp_red"]] == maximum_reduction,][["feat"]][1]
    
    node <-
      split_per_feat %>% filter(feat == best_feat) %>% mutate(side = side, layer_nr = layer_nr) %>% select(-nr)

    # Append node as new row to tree dataframe
    write_csv(
      node %>% select(layer_nr, side, feat, split, lc_mode, rc_mode),
      path = "tree.csv",
      append = TRUE, 
      col_names = ifelse(side=="root", TRUE, FALSE)
    )
    
    #check if number of observations is high enough to split
    nlc <- ifelse(length(as.numeric(unlist(node$nlc)))==0, 0, as.numeric(unlist(node$nlc))) 
    nrc <- ifelse(length(as.numeric(unlist(node$nrc)))==0, 0, as.numeric(unlist(node$nrc)))
    layer_nr <- layer_nr + 1
    
    #Grow left child
    if (nlc > nmin & nlc - minleaf > nmin) {
      tree_grow(
        layer_nr = layer_nr,
        side = "left",
        df = df[df[, best_feat] <= node$split, ],
        labels = labels[df[, best_feat] <= node$split],
        nmin = nmin,
        minleaf = minleaf,
        nfeat = nfeat
      )
    }
    if (nrc > nmin) {
      # Grow right child
      tree_grow(
        layer_nr = layer_nr,
        "right",
        df = df[df[, best_feat] > node$split, ],
        labels = labels[df[, best_feat] > node$split],
        nmin = nmin,
        minleaf = minleaf,
        nfeat = nfeat
      )
    }
    
}

tree_pred <- function(x, tr){
  # A new case is dropped down the tree and assigned to the majority class of each node it passes
  # x: 2d array containing attribute values of cases for which prediction is required
  # tr: tree object created in tree_grow
  # Returns: 1d array with predicted class labels for cases in x
}


```


## Test functions 

```{r}

ytest <- c(1,0,1,1,1,0,0,1,1,0,1)

impurity(ytest)

side <- "root"
x <- credit[,1:ncol(credit)-1]
y <- credit[,ncol(credit)]
nmin <- 2
minleaf <- 1
nfeat <- ncol(credit)-1
layer_nr <- 0

bestsplit(values = credit[,4], labels = credit[,6], minleaf)
  
tree_grow(layer_nr, side, x, labels = y, nmin, minleaf, nfeat)

tree <- read_csv(file = "tree.csv", col_names = T)

```


## Test on pima

```{r}

side <- "root"
x <- pima[,1:ncol(pima)-1]
y <- pima[,ncol(credit)]
nmin <- 2
minleaf <- 1
nfeat <- ncol(pima)-1
layer_nr <- 0
tree_grow(layer_nr, side, x, labels = y, nmin, minleaf, nfeat)

```